// Generated by CoffeeScript 1.10.0
(function() {
  var calculateArrow, describeUnits, drawArrow, drawRect, drawRects, frame, height, parse, svg, width, writeChar, writeDefs;

  svg = d3.select('.stage');

  frame = height = width = null;

  window.render = function(str) {
    var char, diffs, index, j, k, l, len, len1, len2, len3, len4, m, node, nodes, recievers, sender, senders;
    frame = svg.attr('class', 'frame');
    height = frame.style('height').replace('px', '');
    width = frame.style('width').replace('px', '');
    svg.selectAll("*").remove();
    writeDefs();
    nodes = Array.prototype.reduce.call(str, parse, [[], false, 0])[0];
    console.log(nodes);
    senders = [];
    for (index = j = 0, len1 = nodes.length; j < len1; index = ++j) {
      node = nodes[index];
      if (node['throw']) {
        senders.push(index);
      }
    }
    recievers = [];
    for (index = k = 0, len2 = nodes.length; k < len2; index = ++k) {
      node = nodes[index];
      if (node['catch']) {
        recievers.push(index);
      }
    }
    len = str.length;
    diffs = describeUnits(recievers, len);
    drawRects(recievers, diffs, len);
    for (index = l = 0, len3 = str.length; l < len3; index = ++l) {
      char = str[index];
      writeChar(index, char, len);
    }
    for (m = 0, len4 = senders.length; m < len4; m++) {
      sender = senders[m];
      calculateArrow(sender, nodes, senders, recievers, len);
    }
    return null;
  };

  describeUnits = function(recievers, len) {
    var diffs, edges, i, j, k, len1, len2, val;
    edges = [];
    for (j = 0, len1 = recievers.length; j < len1; j++) {
      val = recievers[j];
      edges.push(val);
    }
    edges.push(len);
    diffs = [];
    for (i = k = 0, len2 = edges.length; k < len2; i = ++k) {
      val = edges[i];
      if (edges[i + 1] != null) {
        diffs.push(edges[i + 1] - edges[i]);
      }
    }
    return diffs;
  };

  writeDefs = function() {
    svg.append('defs').append('marker').attr({
      'markerHeight': 5,
      'markerWidth': 5,
      'refX': 0,
      'refY': 0,
      'viewBox': '-5 -5 10 10',
      'id': 'marker_arrow',
      'markerUnits': 'strokeWidth',
      'orient': 'auto'
    }).append('path').attr({
      'd': "M 0,0 m -5,-5 L 5,0 L -5,5 Z",
      'fill': 'darkgrey'
    });
    return null;
  };

  parse = function(state, char, index) {
    var array, currUnit, inUnit, node;
    array = state[0], inUnit = state[1], currUnit = state[2];
    node = {
      character: char,
      int: char !== '[' && char !== ']' ? parseInt(char, 36) : void 0,
      index: index,
      "throw": char !== '[' && char !== ']' ? true : false,
      "catch": !inUnit || char === '[' ? true : false,
      inPlex: (char === '[' || char === ']') || inUnit ? true : false,
      inUnit: inUnit,
      unit: currUnit
    };
    switch (char) {
      case '[':
        inUnit = true;
        break;
      case ']':
        inUnit = false;
        break;
      default:
        inUnit = inUnit;
    }
    currUnit = inUnit ? currUnit : currUnit + 1;
    return [array.concat(node), inUnit, currUnit];
  };

  drawRects = function(recievers, diffs, len) {
    var index, j, len1, val;
    console.log(recievers);
    console.log(diffs);
    for (index = j = 0, len1 = diffs.length; j < len1; index = ++j) {
      val = diffs[index];
      if (val !== 1) {
        drawRect(recievers[index], val, len);
      }
    }
    return null;
  };

  drawRect = function(i, fat, len) {
    console.log("i" + i + " fat" + fat + " len" + len);
    svg.append('rect').attr({
      'x': width / (len + 1) * (i + 0.5) + 5,
      'y': height / 2 - 20,
      'width': width / (len + 1) * 1.01 * fat - 10,
      'height': 40,
      'fill': 'lightblue'
    });
    return null;
  };

  writeChar = function(i, char, len) {
    svg.append('text').text(char).style('text-anchor', 'middle').style('alignment-baseline', 'middle').attr({
      'x': width / (len + 1) * (i + 1),
      'y': height / 2.0
    });
    return null;
  };

  calculateArrow = function(sender, nodes, senders, recievers, len) {
    var bMod, displacement, larger_unit, left_index, left_x, ob_i, pad, right_index, right_x, unwrapped_diff, wrapped_diff, y;
    ob_i = nodes[sender];
    left_index = ob_i['index'];
    larger_unit = ob_i['inPlex'] ? ob_i['unit'] : left_index;
    displacement = ob_i['int'];
    unwrapped_diff = recievers.indexOf(larger_unit) + displacement;
    wrapped_diff = unwrapped_diff % recievers.length;
    right_index = recievers[wrapped_diff];
    left_x = width / (len + 1) * (left_index + 1);
    right_x = width / (len + 1) * (right_index + 1);
    pad = 10;
    bMod = left_x > right_x ? 1 : -1;
    y = (height / 2.0) + (pad * bMod);
    drawArrow(svg, left_x, right_x, y);
    return null;
  };

  drawArrow = function(svg, x1, x2, y) {
    var b, curvestring, h, r;
    if (x1 === x2) {
      b = 20;
      h = 20;
      curvestring = "M" + x1 + "," + y + " c0,-" + h + " " + b + ",-" + h + " " + b + ",10 c0," + (h + 10) + " -" + b + "," + (h + 10) + " -" + b + ",10";
    } else {
      r = 0.5 * Math.abs(x2 - x1);
      curvestring = "M" + x1 + "," + y + " A " + r + "," + r + " 0 0,1 " + x2 + "," + y;
    }
    svg.append("path").attr({
      'd': curvestring,
      'stroke': 'grey',
      'stroke-width': 2,
      'fill': 'none',
      'stroke-linecap': 'round',
      'marker-end': 'url(#marker_arrow)',
      'class': 'link'
    });
    return null;
  };

}).call(this);
