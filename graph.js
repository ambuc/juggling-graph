// Generated by CoffeeScript 1.10.0
(function() {
  var calculateArrow, drawArrow, drawRect, frame, height, parseStr, svg, width, writeChar;

  svg = d3.select('.stage');

  frame = svg.attr('class', 'frame');

  height = frame.style('height').replace('px', '');

  width = frame.style('width').replace('px', '');

  window.render = function(str) {
    var char, charheight, charwidth, index, j, k, l, len, len1, len2, len3, len4, len5, m, n, node, nodes, recievers, sender, senders;
    svg.selectAll("*").remove();
    svg.append('defs').append('marker').attr({
      'markerHeight': 5,
      'markerWidth': 5,
      'refX': 0,
      'refY': 0,
      'viewBox': '-5 -5 10 10',
      'id': 'marker_arrow',
      'markerUnits': 'strokeWidth',
      'orient': 'auto'
    }).append('path').attr({
      'd': "M 0,0 m -5,-5 L 5,0 L -5,5 Z",
      'fill': 'darkgrey'
    });
    charheight = 20;
    charwidth = 10;
    nodes = parseStr(str, 0);
    nodes.pop();
    console.log(nodes);
    senders = [];
    recievers = [];
    for (index = j = 0, len1 = nodes.length; j < len1; index = ++j) {
      node = nodes[index];
      if (node['throw']) {
        senders.push(index);
      }
    }
    for (index = k = 0, len2 = nodes.length; k < len2; index = ++k) {
      node = nodes[index];
      if (node['catch']) {
        recievers.push(index);
      }
    }
    console.log('senders', senders);
    console.log('recievers', recievers);
    len = str.length;
    for (index = l = 0, len3 = nodes.length; l < len3; index = ++l) {
      node = nodes[index];
      if (node['inPlex'] === true) {
        drawRect(index, len);
      }
    }
    for (index = m = 0, len4 = str.length; m < len4; index = ++m) {
      char = str[index];
      writeChar(index, char, len);
    }
    for (n = 0, len5 = senders.length; n < len5; n++) {
      sender = senders[n];
      calculateArrow(nodes, senders, recievers, sender, len);
    }
    return null;
  };

  parseStr = function(str, index, inUnit, currUnit) {
    var char, node;
    if (inUnit == null) {
      inUnit = false;
    }
    if (currUnit == null) {
      currUnit = 0;
    }
    if (str === "") {

    } else {
      char = str[0];
      console.log(inUnit);
      node = {
        character: char,
        int: char !== '[' && char !== ']' ? parseInt(char, 36) : void 0,
        index: index,
        "throw": char !== '[' && char !== ']' ? true : false,
        "catch": !inUnit || char === '[' ? true : false,
        inPlex: (char === '[' || char === ']') || inUnit ? true : false,
        inUnit: inUnit,
        unit: currUnit
      };
      switch (char) {
        case '[':
          inUnit = true;
          break;
        case ']':
          inUnit = false;
          break;
        default:
          inUnit = inUnit;
      }
      currUnit = inUnit ? currUnit : currUnit + 1;
      return [node].concat(parseStr(str.slice(1), index + 1, inUnit, currUnit));
    }
  };

  drawRect = function(i, len) {
    return svg.append('rect').attr({
      'x': width / (len + 1) * (i + 0.5),
      'y': height / 2 - 20,
      'width': width / (len + 1) * 1.01,
      'height': 40,
      'fill': 'lightblue'
    });
  };

  writeChar = function(i, char, len) {
    svg.append('text').text(char).style('text-anchor', 'middle').style('alignment-baseline', 'middle').attr({
      'x': width / (len + 1) * (i + 1),
      'y': height / 2.0
    });
    return null;
  };

  calculateArrow = function(nodes, senders, recievers, sender, len) {
    var bMod, displacement, larger_unit, left_index, left_x, ob_i, pad, right_index, right_x, unwrapped_diff, wrapped_diff, y;
    ob_i = nodes[sender];
    left_index = ob_i['index'];
    larger_unit = ob_i['inPlex'] ? ob_i['unit'] : left_index;
    displacement = ob_i['int'];
    unwrapped_diff = recievers.indexOf(larger_unit) + displacement;
    wrapped_diff = unwrapped_diff % recievers.length;
    right_index = recievers[wrapped_diff];
    left_x = width / (len + 1) * (left_index + 1);
    right_x = width / (len + 1) * (right_index + 1);
    pad = 10;
    bMod = left_x > right_x ? true : false;
    y = (height / 2.0) + (pad * bMod);
    drawArrow(svg, left_x, right_x, y);
    return null;
  };

  drawArrow = function(svg, x1, x2, y) {
    var curvestring, r;
    r = 0.5 * Math.abs(x2 - x1);
    curvestring = "M" + x1 + "," + y + " A " + r + "," + r + " 0 0,1 " + x2 + "," + y;
    svg.append("path").attr({
      'd': curvestring,
      'stroke': 'grey',
      'stroke-width': 2,
      'fill': 'none',
      'stroke-linecap': 'round',
      'marker-end': 'url(#marker_arrow)',
      'class': 'link'
    });
    return null;
  };

}).call(this);
